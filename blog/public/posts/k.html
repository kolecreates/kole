<!-- @layout './basic-layout.html' { "title": "k" } -->
<article>
  <h2>k</h2>
  <p class="meta">Posted on August 8, 2024</p>

  <h3>Rant</h3>
  <p>
    Most programming languages drop you off the IO cliff, leave you in the
    middle of turing complete nowhere, invoice you after "it works on my
    machine".
  </p>
  <p>
    We end up installing huge graphs of dependencies, some well maintained, some
    not, some secure, some vulnerable, some synergize with eachother, many
    don't.
  </p>
  <p>
    We end up paying for and fetching against third-party APIs to do things our
    language cannot do, or there is no open source package for, or our hardware
    cannot do.
  </p>
  <p>
    We end up setting up docker stacks, kubernete clusters, "App Platform"
    stacks, insert orchestration abstraction here, composed of proprietary and
    open source images that are wired together to have some emergent behavior.
  </p>
  <p>
    We use postgres or msql because we need persistence, it's too hard to manage
    a database, so we use managed database service in the cloud, but those
    managed services have bad DX and are limited so we use PaaS that are
    wrappers over the same managed service.
  </p>
  <p>
    We don't test our systems - or orchestrate dependencies, mocks, pipelines,
    headless browsers wrapped in SaaS products, to give developers who don't
    test a reason to stick to their ways.
  </p>
  <p>
    Some language ecosystems are better at X, don't have problem Y, can do Z,
    can't do V, language U is better than language P for B but not A, good for E
    but slow for anything else. Language 123 is perfect and solves all problems
    but won't be 1.0 for 10 years. Language AAA solves 90% of all problems, but
    it doesn't have any open source packages I can leech off of to build an app
    - and I'll still be fired for using it in production even if it can serve 10
    billion hello world requests per second.
  </p>
  <p>
    We write our code on OS 1 but it doesn't work on OS 2, and we search the
    internet for wrappers that will port it to mobile, or we'd like to run it on
    an Arduino that has 2kb of flash memory but a hello world has 4MB runtime
    overhead.
  </p>

  <h3>The reality</h3>
  <p>
    Making computers is insaley insanely <em>insanely</em> complicated. Many
    many <em>many</em> humans are needed to build one like we expect today.
    Software is also quite complicated. Many <em>many</em> humans are needed to
    develop the stuff we use today. It is a shock that any of it works at all.
  </p>
  <p>
    So many humans involved makes things even more complicated. There is
    intrinsic complexity to computation and engineering - but emergent
    complexity in so many humans developing the technology in parallel.
  </p>
  <p>
    Standards and protocols are something we humans developed to wrangle the
    mess. k is a protocol - a way to talk to computers and for computers to talk
    to each other.
  </p>

  <h3>The protocol</h3>
  <p>
    Humans talk to computers through characters over keys, clicks over buttons,
    taps over screens, voice over microphone.
  </p>
  <p>Computers talk to each other through bits over a wire.</p>
  <p>Computers talk to humans through pixels, audio.</p>
  <p>to be continued...</p>
</article>
